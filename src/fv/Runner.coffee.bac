class pkg.Runner

  constructor: (@_registry) ->
    @_date = new Date()
    @_env  = new pkg.Environment()

  # W jakis sposob wynik musi sie dodac do html'a...
  # Byc moze lepiej po prostu pozostawic retrospekcje?
  create: (dom) ->

  update: (node) =>
    return if node.disposed

    handler = @_registry.get(node.type())
    ev = node.get_changes() # Co tak naprawde okreslamy? Chyba powinnismy okreslic

    # Chyba oczekujemy, ze ev zwroci nam informacje o attrs badz nowe/stare nodes
    # do zmiany. Czyli on wewnatrz musi wykonac evaluate, etc...?

    if ev.attrs
      handler.update?(node, ev)

    if ev.old_nodes # pkg.Node?
      @_dispose_node(c, node) for c in ev.old_nodes

    if ev.new_nodes # reference?
      @_env.restore_node(node.env)
      @_create_node(c, node) for c in ev.new_nodes
      @_env.pop_node()

  _create_node: (ref, p) ->
    @_env.push_node()

    node = new pkg.Action(ref, p, @_env, @)
    node.evaluate(@_date)
    node.submit_changes()

    handler = @_registry.get(ref.type)
    handler.create?(node, @_env)
    handler.update?(node, pkg.EVENT_ALL)

    @_run_node(c, node) for c in node.ref_nodes() # references...
    handler.finalize?(node, @_env)

    node.finalized = true
    node.env = @_env.pop_node()
    return node

  _dispose_node: (node, p) ->
    p.detach(node)

    node.disposed = true
    node.unregister_all()

    @_dispose_node(c, node) for c in node.nodes() # nodes!
